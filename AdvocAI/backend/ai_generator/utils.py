"""
AdvocAI - Legal Document Generation Agent
A sophisticated, stateful multi-turn conversational agent for legal document drafting.
Uses LangGraph for state management and Google Gemini for AI generation.
"""

import google.generativeai as genai
from django.conf import settings
import json
import re
from typing import TypedDict, Annotated, List, Dict, Any, Optional
from langgraph.graph import StateGraph, END


# ============================================================================
# SYSTEM PROMPT - The AI's "Personality" and Core Instructions
# ============================================================================

LEGAL_ASSISTANT_SYSTEM_PROMPT = """
## 1. ðŸ“œ Role and Identity
You are an expert AI Legal Drafting Assistant.
* **Persona:** Precise, helpful, and cautious.
* **Primary Jurisdiction:** Your primary focus and expertise is the **jurisdiction of India**.
* **Fallback Jurisdiction:** If an India-specific document is not feasible or not requested, you will provide a **generic, jurisdiction-agnostic** template as a starting point.

## 2. ðŸŽ¯ Core Mandate
Your primary function is to assist users by:
* **Generating First Drafts:** Create preliminary drafts of legal documents, prioritizing Indian formats.
* **Asking Clarifying Questions:** Proactively gather all necessary variables (names, addresses, amounts, dates, etc.).
* **Utilizing Search:** You must use your search tools to find relevant templates, common clauses, and jurisdiction-specific information (especially for India) to inform your draft.
* **Structuring Documents:** Format all output according to standard legal conventions.
* **Explaining Clauses:** Describe the general purpose of common clauses in a purely educational and informational context.

## 3. ðŸ›‘ CRITICAL GUARDRAIL: The "No Legal Advice" Directive
This is your most important rule. You are a drafting tool, **NOT a lawyer**. You **CANNOT** provide legal advice, legal opinions, or any form of legal counsel.

**The Rule:**
You must **never** interpret a user's specific situation, predict a legal outcome, or give an opinion on the fairness or legality of a situation. (e.g., Refuse "Is this contract fair?").

**Mandatory Actions:**
1.  **Refuse Legal Advice:** If asked for an opinion, you must refuse.
2.  **State Your Limitation:** Politely state your role: "I cannot provide legal advice. My purpose is to help you draft a document. For a review of your specific situation or for legal counsel, you must consult a qualified legal professional."
3.  **Include a Dynamic Disclaimer:** You must select and append the correct disclaimer from the two options below.

## 4. âš–ï¸ Dynamic Disclaimer System (MANDATORY)
You must choose **one** of the following disclaimers to append to **every** draft you generate.

> **Disclaimer A (Use for India-Specific Drafts):**
> ---
> **IMPORTANT DISCLAIMER (INDIA):** This document was generated by an AI assistant. It is for informational and drafting purposes ONLY and is NOT a substitute for legal advice. It is intended as a starting point based on common formats in India. Laws and regulations vary, and this draft may not be suitable for your specific needs. **You MUST consult a qualified legal professional in India** to review this document, ensure its compliance, and advise you on your specific legal situation before using it.
> ---

> **Disclaimer B (Use for Generic/Agnostic Drafts):**
> ---
> **IMPORTANT DISCLAIMER (GENERIC):** This document was generated by an AI assistant and is a generic template. It is NOT specific to any country, state, or jurisdiction. It is for informational and drafting purposes ONLY and is NOT a substitute for legal advice. This draft WILL NOT be compliant without a thorough review and customization by a legal expert. It is CRITICAL that you consult a qualified legal professional in your specific jurisdiction to review and adapt this document to your needs before using it.
> ---

## 5. ðŸ‡®ðŸ‡³ Operational Guidelines
* **Jurisdictional Priority:** Priority 1 is India (use search for local laws). Priority 2 is Generic.
* **Search Integration:** Use search as a standard step to verify terminology and find document templates *before* you start drafting.
* **Terminology:** Use Indian terms (Lessor/Lessee, lakhs) for India-mode. Use universal terms (Landlord/Tenant) for Generic-mode.
* **Formality:** Maintain a formal, precise, and objective tone.

## 6. âš™ï¸ Interaction Workflow
1.  **Identify Intent:** User asks for a document (e.g., "I need a Non-Disclosure Agreement").
2.  **Search & Analyze (Internal Step):** Use your search tool (e.g., `Google Search("Indian NDA template standard clauses")`).
3.  **Confirm Jurisdiction & Gather Info:** Based on your search, state your plan and ask for details (e.g., "I will draft an NDA for India. To do this, I need... 1. The Disclosing Party's name...").
4.  **Generate Draft:** Produce the document.
5.  **Present with Correct Disclaimer:** Append Disclaimer A or B.

## 7. ðŸ“‹ Output Format
* When generating the final document, provide it in JSON format: {"type": "document", "text": "...your Markdown document here...", "jurisdiction": "india" or "generic"}
* Use well-structured **Markdown format** for the document itself with proper headings, lists, bold, and italics.
* **Signature Handling:** If the user uploads a signature with a URL, include it at signature lines using: `![Signature]({signature_url})`
"""


# ============================================================================
# STATE DEFINITION - Manages conversation flow and collected information
# ============================================================================

class ConversationState(TypedDict):
    """
    Defines the state structure for the conversational agent.
    This state is passed between nodes in the LangGraph workflow.
    """
    messages: List[Any]  # Conversation history
    current_intent: str  # "document_generation", "summarization", "other"
    document_type: str  # e.g., "NDA", "Rental Agreement", etc.
    is_feasible: bool  # Whether the document request is feasible
    jurisdiction: str  # "india" or "generic"
    gathered_info: Dict[str, Any]  # Collected user details
    needs_more_info: bool  # Whether we need to ask more questions
    user_wants_template: bool  # User opted for blank template
    user_wants_dummy_data: bool # User opted for dummy data
    final_document: str  # Generated document
    signature_url: Optional[str]  # Uploaded signature URL
    next_step: str  # Controls workflow routing


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def get_llm():
    """Initialize and return the Gemini LLM using direct google.generativeai library."""
    if not settings.GEMINI_API_KEY or settings.GEMINI_API_KEY == '':
        raise ValueError('GEMINI_API_KEY is not configured in your .env file or is empty.')
    
    genai.configure(api_key=settings.GEMINI_API_KEY)
    # Use the same model as document_summarizer for consistency
    return genai.GenerativeModel('gemini-flash-lite-latest')


def extract_json_from_response(text: str) -> Optional[Dict]:
    """
    Extracts JSON from AI response that may contain code blocks.
    Returns the parsed JSON dict or None if not found.
    """
    # Try to find JSON in code blocks first
    json_pattern = r'```json\s*(\{.*?\})\s*```'
    match = re.search(json_pattern, text, re.DOTALL)
    
    if match:
        try:
            return json.loads(match.group(1))
        except json.JSONDecodeError:
            pass
    
    # Try to find raw JSON
    try:
        # Find anything that looks like a JSON object
        json_pattern = r'\{[^{}]*"type"[^{}]*"document"[^{}]*\}'
        match = re.search(json_pattern, text, re.DOTALL)
        if match:
            return json.loads(match.group(0))
    except json.JSONDecodeError:
        pass
    
    return None


def get_disclaimer(jurisdiction: str) -> str:
    """Returns the appropriate disclaimer based on jurisdiction."""
    if jurisdiction.lower() == "india":
        return """

---

**IMPORTANT DISCLAIMER (INDIA):** This document was generated by an AI assistant. It is for informational and drafting purposes ONLY and is NOT a substitute for legal advice. It is intended as a starting point based on common formats in India. Laws and regulations vary, and this draft may not be suitable for your specific needs. **You MUST consult a qualified legal professional in India** to review this document, ensure its compliance, and advise you on your specific legal situation before using it.

---
"""
    else:
        return """

---

**IMPORTANT DISCLAIMER (GENERIC):** This document was generated by an AI assistant and is a generic template. It is NOT specific to any country, state, or jurisdiction. It is for informational and drafting purposes ONLY and is NOT a substitute for legal advice. This draft WILL NOT be compliant without a thorough review and customization by a legal expert. It is CRITICAL that you consult a qualified legal professional in your specific jurisdiction to review and adapt this document to your needs before using it.

---
"""


# ============================================================================
# GRAPH NODES - Each node represents a step in the workflow
# ============================================================================

def intent_classification_node(state: ConversationState) -> ConversationState:
    """
    Node 1: Classifies the user's intent.
    Determines if this is a document generation, modification, or something else.
    """
    model = get_llm()
    
    # Get the last user message
    last_message = state["messages"][-1] if state["messages"] else ""
    user_query = last_message.get("content", "") if isinstance(last_message, dict) else str(last_message)
    
    # Check if there's existing document context (indicates this is a modification request)
    has_document_context = "Current document content:" in user_query
    
    if has_document_context:
        # This is a document modification/revision request - skip to generation
        state["current_intent"] = "document_modification"
        state["is_feasible"] = True
        state["document_type"] = "Document Revision"
        state["gathered_info"] = {"modification_request": "yes"}
        state["next_step"] = "generate_document"
        return state
    
    # Check for previous bot message to provide context
    context_prompt = ""
    if len(state["messages"]) >= 2:
        # The last message is user, the one before is likely bot (or system)
        # We look for the last message that is NOT from the user
        for msg in reversed(state["messages"][:-1]):
            role = msg.get("role", "") if isinstance(msg, dict) else ""
            if role != "user":
                content = msg.get("content", "") if isinstance(msg, dict) else str(msg)
                context_prompt = f"Previous System Message: \"{content}\"\n"
                break

    classification_prompt = f"""You are an intent classifier. Analyze this user query and classify the intent.
    
    {context_prompt}
    User Query: "{user_query}"

    Respond with ONLY ONE of these intents:
    - "document_generation" - if the user wants to create, draft, or generate a NEW legal document
    - "summarization" - if the user wants to summarize a document
    - "general_chat" - for greetings, questions about capabilities, or general legal questions not resulting in a document
    - "providing_information" - if the user is answering the Previous System Message (e.g. providing details, saying "blank template")
    - "other" - for any other request

    Respond with just the intent name, nothing else."""

    try:
        response = model.generate_content(
            classification_prompt,
            generation_config=genai.types.GenerationConfig(
                temperature=0.3,
                max_output_tokens=50,
            )
        )
        intent = response.candidates[0].content.parts[0].text.strip().lower()
        
        # Validate intent
        valid_intents = ["document_generation", "summarization", "general_chat", "providing_information", "other"]
        if intent not in valid_intents:
            intent = "other"
        
        # Handle providing_information logic
        if intent == "providing_information":
            # Attempt to extract document type from context
            # We look for "To create your [Doc Type], please" pattern in the previous message
            doc_type = "Generic Document" # Default
            if context_prompt:
                # We look for "To create your [Doc Type], please" pattern in the previous message
                # Handle potential markdown bolding like **Lease Agreement**
                match = re.search(r"To create your (.*?), please", context_prompt, re.IGNORECASE)
                if match:
                    # Clean up any markdown chars like * or _
                    raw_type = match.group(1)
                    doc_type = re.sub(r"[\*_]", "", raw_type).strip()
            
            state["document_type"] = doc_type
            state["gathered_info"] = {"status": "pending_response"} # Signal that we are expecting a response
            
        state["current_intent"] = intent
        state["next_step"] = "route_intent"
    except Exception as e:
        print(f"Error in intent classification: {e}")
        state["current_intent"] = "other"
        state["next_step"] = "route_intent"
    
    return state


def feasibility_check_node(state: ConversationState) -> ConversationState:
    """
    Node 2: Checks if the document request is feasible.
    Rejects overly complex documents like international mergers.
    """
    model = get_llm()
    
    last_message = state["messages"][-1]
    user_query = last_message.get("content", "") if isinstance(last_message, dict) else str(last_message)
    
    feasibility_prompt = f"""You are a document feasibility analyzer. Analyze this document request and determine feasibility.

User Request: "{user_query}"

Complex documents we CANNOT generate:
- International merger agreements
- Complex corporate restructuring documents
- Multi-jurisdictional contracts
- Securities offering documents
- Complex intellectual property licensing agreements
- International trade agreements

Common documents we CAN generate:
- Non-Disclosure Agreements (NDA)
- Rental/Lease Agreements
- Employment Agreements
- Service Agreements
- Promissory Notes
- Power of Attorney
- Affidavits
- Purchase Agreements
- Partnership Agreements
- Loan Agreements

Respond with JSON:
{{"feasible": true/false, "document_type": "name of document", "reason": "explanation if not feasible", "user_message": "Message to show to the user if not feasible"}}

If the request is vague (e.g. "create a document"), set "feasible": false and "user_message": "Could you please specify what kind of document you would like to create? (e.g., NDA, Rental Agreement, Employment Contract)".
"""

    try:
        response = model.generate_content(
            feasibility_prompt,
            generation_config=genai.types.GenerationConfig(
                temperature=0.3,
                max_output_tokens=200,
            )
        )
        response_text = response.candidates[0].content.parts[0].text
        
        # Extract JSON from response
        result = extract_json_from_response(response_text)
    except Exception as e:
        # Handle any errors in feasibility check
        state["is_feasible"] = True
        state["document_type"] = "Legal Document"
        state["next_step"] = "gather_info"
        return state
    
    if result:
        state["is_feasible"] = result.get("feasible", False)
        state["document_type"] = result.get("document_type", "Unknown Document")
        
        if not state["is_feasible"]:
            # Add AI message explaining infeasibility or asking for clarification
            user_message = result.get("user_message")
            if not user_message:
                reason = result.get("reason", "This document is too complex for automated generation.")
                user_message = f"I am not capable of generating a document of that complexity. {reason} I recommend consulting with a legal professional directly for this type of document."
            
            state["messages"].append({"role": "assistant", "content": user_message})
            state["next_step"] = "end"
        else:
            state["next_step"] = "gather_info"
    else:
        # Default to feasible if we can't parse
        state["is_feasible"] = True
        state["document_type"] = "Legal Document"
        state["next_step"] = "gather_info"
    
    return state


def get_document_questions(document_type: str) -> str:
    """
    Returns predefined comprehensive questions for common document types.
    """
    questions_map = {
        "rental agreement": """To create your Rental Agreement, please provide ALL of the following information:

**1. LANDLORD DETAILS:**
   - Full legal name
   - Complete address
   - Contact number
   - Email address

**2. TENANT DETAILS:**
   - Full legal name(s) of all tenants
   - Current address(es)
   - Contact numbers
   - Email addresses

**3. PROPERTY DETAILS:**
   - Complete property address (with unit/flat number)
   - Type of property (apartment, house, commercial)
   - Included items (parking space, appliances, furniture, etc.)

**4. LEASE TERMS:**
   - Lease start date (e.g., December 1, 2025)
   - Lease end date (e.g., November 30, 2026)
   - Total lease duration (e.g., 12 months)
   - Agreement signing date

**5. FINANCIAL TERMS:**
   - Monthly rent amount (e.g., â‚¹25,000)
   - Rent due date (e.g., 5th of each month)
   - Payment method (bank transfer, check, cash)
   - Security deposit amount (e.g., â‚¹50,000)
   - Any other deposits (pet deposit, key deposit)
   - Late payment charges/penalties

**6. UTILITIES & MAINTENANCE:**
   - Which utilities are included in rent?
   - Which utilities tenant must pay separately?
   - Maintenance charges responsibility

**7. SPECIAL TERMS (if any):**
   - Pet policy
   - Subletting allowed/not allowed
   - Notice period for termination
   - Any other special conditions

**Please provide all this information in one message.** Or simply say "blank template" if you want to fill it yourself.""",

        "lease agreement": """To create your Lease Agreement, please provide ALL of the following information:

**1. LESSOR (Owner) DETAILS:**
   - Full legal name
   - Complete address
   - Contact details

**2. LESSEE (Tenant) DETAILS:**
   - Full legal name(s)
   - Current address(es)
   - Contact details

**3. PROPERTY DETAILS:**
   - Complete property address
   - Property description
   - Included amenities/items

**4. LEASE TERMS:**
   - Start date
   - End date
   - Duration
   - Signing date

**5. FINANCIAL TERMS:**
   - Monthly rent
   - Due date
   - Payment method
   - Security deposit
   - Other charges

**6. ADDITIONAL TERMS:**
   - Utilities responsibility
   - Maintenance terms
   - Special conditions

**Please provide all details in one message.** Or say "blank template" for an empty form.""",

        "employment agreement": """To create your Employment Agreement, please provide ALL of the following information:

**1. EMPLOYER DETAILS:**
   - Company/Organization name
   - Registered address
   - Contact information

**2. EMPLOYEE DETAILS:**
   - Full legal name
   - Current address
   - Contact details
   - Date of birth (if required)

**3. POSITION DETAILS:**
   - Job title/designation
   - Department
   - Reporting manager
   - Job location

**4. EMPLOYMENT TERMS:**
   - Start date
   - Employment type (permanent, contract, probation)
   - Probation period (if any)
   - Work hours/schedule

**5. COMPENSATION:**
   - Annual salary/monthly salary
   - Payment frequency (monthly, bi-weekly)
   - Payment method
   - Bonus structure (if any)
   - Benefits (health insurance, PF, etc.)

**6. LEAVE POLICY:**
   - Annual leave days
   - Sick leave policy
   - Other leaves

**7. ADDITIONAL TERMS:**
   - Notice period for resignation
   - Confidentiality clauses
   - Non-compete terms (if any)
   - Other special conditions

**Provide all information in one message.** Or say "blank template".""",

        "nda": """To create your Non-Disclosure Agreement (NDA), please provide ALL of the following:

**1. DISCLOSING PARTY:**
   - Full legal name
   - Address
   - Contact details

**2. RECEIVING PARTY:**
   - Full legal name
   - Address
   - Contact details

**3. NDA TYPE:**
   - Unilateral (one-way) or Mutual (two-way)?

**4. PURPOSE:**
   - What is the purpose of disclosure?
   - What project/business relationship?

**5. CONFIDENTIAL INFORMATION:**
   - What types of information will be shared?
   - Any specific exclusions?

**6. TERMS:**
   - Agreement start date
   - Duration of confidentiality (e.g., 2 years, 5 years)
   - Agreement signing date

**7. JURISDICTION:**
   - Which state/country laws apply?
   - Dispute resolution location

**Provide all details in one message.** Or say "blank template"."""
    }
    
    # Normalize document type
    doc_type_lower = document_type.lower()
    
    # Try exact match first
    if doc_type_lower in questions_map:
        return questions_map[doc_type_lower]
    
    # Try partial matches
    for key in questions_map:
        if key in doc_type_lower or doc_type_lower in key:
            return questions_map[key]
    
    # Generic fallback
    return f"""To create your {document_type}, please provide ALL of the following information:

**1. PARTY DETAILS:**
   - Names and addresses of all parties involved
   - Contact information

**2. KEY TERMS:**
   - Important dates (start, end, signing)
   - Duration or term length

**3. FINANCIAL TERMS (if applicable):**
   - Amounts, payment terms, deposits

**4. SCOPE & OBLIGATIONS:**
   - What is being provided/agreed upon
   - Responsibilities of each party

**5. SPECIAL CONDITIONS:**
   - Any specific terms, conditions, or restrictions
   - Jurisdiction/governing law

**Please provide all information in one detailed message.** Or say "blank template" if you prefer."""


def information_gathering_node(state: ConversationState) -> ConversationState:
    """
    Node 3: Asks the user for necessary information ALL AT ONCE.
    Single-turn question asking, then proceeds directly to generation.
    """
    # Check if user wants a blank template
    last_user_msg = state["messages"][-1]
    user_text = last_user_msg.get("content", "") if isinstance(last_user_msg, dict) else str(last_user_msg)
    
    if any(phrase in user_text.lower() for phrase in ["blank template", "fill it myself", "i'll fill", "leave blank", "just give me"]):
        state["user_wants_template"] = True
        state["needs_more_info"] = False
        state["next_step"] = "generate_document"
        return state
    
    # Check if user wants dummy data
    if any(phrase in user_text.lower() for phrase in ["dummy data", "example data", "sample data", "fake data", "test data"]):
        state["user_wants_dummy_data"] = True
        state["needs_more_info"] = False
        state["next_step"] = "generate_document"
        return state
    
    # Check if this is the first time (we haven't asked questions yet)
    if not state.get("gathered_info"):
        # First time - ask ALL questions at once using predefined template
        state["gathered_info"] = {}
        
        # Get comprehensive questions for this document type
        questions = get_document_questions(state['document_type'])
        
        state["messages"].append({"role": "assistant", "content": questions})
        state["needs_more_info"] = True
        state["next_step"] = "wait_for_user"
    else:
        # Second time - user has provided answers, store them and proceed to generation
        user_response = user_text
        
        # Store all the user's response
        state["gathered_info"]["complete_response"] = user_response
        
        # Always proceed to document generation after receiving user's response
        state["needs_more_info"] = False
        state["next_step"] = "generate_document"
    
    return state


def document_generation_node(state: ConversationState) -> ConversationState:
    """
    Node 4: Generates the final legal document or modifies existing one.
    Handles both new generation and revision requests.
    """
    model = get_llm()
    
    # Check if this is a modification request (existing document in messages)
    last_message = state["messages"][-1] if state["messages"] else {}
    user_query = last_message.get("content", "") if isinstance(last_message, dict) else str(last_message)
    
    is_modification = "Current document content:" in user_query
    
    if is_modification:
        # Extract the existing document and modification request
        parts = user_query.split("User request:")
        existing_doc = parts[0].replace("Current document content:", "").strip()
        modification_request = parts[1].strip() if len(parts) > 1 else ""
        
        generation_prompt = f"""You are a legal document editor. Modify the existing document according to the user's request.

**EXISTING DOCUMENT:**
{existing_doc}

**USER'S MODIFICATION REQUEST:**
{modification_request}

**INSTRUCTIONS:**
1. Make ONLY the changes requested by the user
2. Preserve all other content, formatting, and structure
3. Maintain proper Markdown formatting
4. Keep the document professional and formal
5. If the modification affects legal terms, ensure consistency throughout

Respond with JSON in this exact format:
{{"type": "document", "text": "...complete modified markdown document here...", "jurisdiction": "india" or "generic"}}

Generate the modified document now."""
        
    else:
        # New document generation
        if state.get("user_wants_template"):
            generation_instruction = """Generate a blank template. 
            IMPORTANT: Use underscores (e.g., _________________) for all placeholders where the user needs to fill in information. 
            Do NOT use bracketed placeholders like [PARTY NAME]. 
            Example: "Name: _________________" instead of "Name: [Name]"."""
        elif state.get("user_wants_dummy_data"):
            generation_instruction = """Generate the document filled with realistic DUMMY DATA (example names, addresses, dates, amounts).
            CRITICAL: Do NOT use placeholders like [Party Name] or [Date]. 
            You MUST fill every single field with realistic example data.
            Example: Use "John Doe" instead of "[Party Name]". Use "â‚¹25,000" instead of "[Amount]".
            The document should look like a completed, ready-to-sign agreement."""
        else:
            generation_instruction = f"""Use this information to fill in the document:
{json.dumps(state.get('gathered_info', {}), indent=2)}

For any missing information, use placeholders like [PARTY NAME], [DATE], etc."""
        
        # Check for signature URL
        signature_instruction = ""
        if state.get("signature_url"):
            signature_instruction = f"""
**IMPORTANT**: The user has uploaded a signature. Use this URL at signature lines:
![Signature]({state['signature_url']})
"""
        
        generation_prompt = f"""You are a legal document generation assistant. Generate a complete {state['document_type']}.

{generation_instruction}

{signature_instruction}

Requirements:
1. **TITLE**: The document title MUST be "{state['document_type'].upper()}" (e.g., "LEASE AGREEMENT", "NON-DISCLOSURE AGREEMENT"). Do NOT use "Generic Agreement" or "Generic Document".
2. Use proper Markdown formatting with headings (##), bold (**text**), and lists
3. Follow standard legal document structure for {state['document_type']}
4. Include all typical clauses for this document type
5. Use Indian legal terminology if jurisdiction is India (Lessor/Lessee, lakhs, etc.)
6. Make it professional and formal

Respond with JSON in this exact format:
{{"type": "document", "text": "...full markdown document here...", "jurisdiction": "india" or "generic"}}

Generate the document now."""

    try:
        response = model.generate_content(
            generation_prompt,
            generation_config=genai.types.GenerationConfig(
                temperature=0.7,
                max_output_tokens=3072,
            )
        )
        response_text = response.candidates[0].content.parts[0].text
        
        # Extract the document
        result = extract_json_from_response(response_text)
        
        if result and result.get("type") == "document":
            document_text = result.get("text", "")
            jurisdiction = result.get("jurisdiction", "generic")
            state["jurisdiction"] = jurisdiction
            
            # Append the appropriate disclaimer (only for new documents, not modifications)
            if not is_modification:
                disclaimer = get_disclaimer(jurisdiction)
                final_document = document_text + disclaimer
            else:
                # For modifications, check if disclaimer already exists
                if "IMPORTANT DISCLAIMER" in document_text:
                    final_document = document_text
                else:
                    disclaimer = get_disclaimer(jurisdiction)
                    final_document = document_text + disclaimer
            
            state["final_document"] = final_document
            state["messages"].append({"role": "assistant", "content": f"```json\n{json.dumps({'type': 'document', 'text': final_document})}\n```"})
        else:
            # Fallback if JSON parsing fails
            state["final_document"] = response_text
            state["messages"].append({"role": "assistant", "content": response_text})
    except Exception as e:
        # Error handling
        error_msg = f"I encountered an error generating the document: {str(e)}"
        state["final_document"] = error_msg
        state["messages"].append({"role": "assistant", "content": error_msg})
    
    state["next_step"] = "end"
    return state


def general_chat_node(state: ConversationState) -> ConversationState:
    """
    Node: Handles general chat and questions.
    """
    model = get_llm()
    last_message = state["messages"][-1]
    user_query = last_message.get("content", "") if isinstance(last_message, dict) else str(last_message)
    
    prompt = f"""You are AdvocAI, a helpful legal AI assistant.
User Query: "{user_query}"

Respond naturally and helpfully. If the user asks what you can do, explain your document drafting capabilities.
Do NOT generate a JSON document. Just provide a text response.
"""
    try:
        response = model.generate_content(prompt)
        response_text = response.candidates[0].content.parts[0].text
        state["messages"].append({"role": "assistant", "content": response_text})
    except Exception as e:
        state["messages"].append({"role": "assistant", "content": "I'm sorry, I'm having trouble responding right now."})
        
    state["next_step"] = "end"
    return state


def route_other_features_node(state: ConversationState) -> ConversationState:
    """
    Node: Routes to other features (summarization, etc.)
    This is a stub that you can extend with your other AI features.
    """
    state["messages"].append({"role": "assistant", "content": "This feature (summarization/other) is handled by a different part of the system. Please use the appropriate endpoint."})
    state["next_step"] = "end"
    return state


# ============================================================================
# ROUTING FUNCTIONS - Control flow between nodes
# ============================================================================

def route_after_intent(state: ConversationState) -> str:
    """Routes based on classified intent."""
    intent = state.get("current_intent", "other")
    
    if intent == "document_generation":
        return "feasibility_check"
    elif intent == "document_modification":
        return "generate_document"  # Skip feasibility and info gathering for modifications
    elif intent == "general_chat":
        return "general_chat"
    elif intent == "providing_information":
        return "gather_info"
    elif intent in ["summarization", "other"]:
        return "other_features"
    else:
        return "other_features"


def route_after_feasibility(state: ConversationState) -> str:
    """Routes based on feasibility check."""
    if state.get("is_feasible"):
        return "gather_info"
    else:
        return END


def route_after_gathering(state: ConversationState) -> str:
    """Routes based on whether we need more info."""
    if state.get("needs_more_info"):
        return END  # Wait for user's next message
    else:
        return "generate_document"


# ============================================================================
# GRAPH CONSTRUCTION - Builds the LangGraph workflow
# ============================================================================

def build_legal_document_graph():
    """
    Constructs and returns the StateGraph for legal document generation.
    """
    workflow = StateGraph(ConversationState)
    
    # Add all nodes
    workflow.add_node("intent_classification", intent_classification_node)
    workflow.add_node("feasibility_check", feasibility_check_node)
    workflow.add_node("gather_info", information_gathering_node)

    workflow.add_node("generate_document", document_generation_node)
    workflow.add_node("general_chat", general_chat_node)
    workflow.add_node("other_features", route_other_features_node)
    
    # Set entry point
    workflow.set_entry_point("intent_classification")
    
    # Add conditional edges
    workflow.add_conditional_edges(
        "intent_classification",
        route_after_intent,
        {
            "feasibility_check": "feasibility_check",
            "generate_document": "generate_document",  # Direct route for document modifications
            "general_chat": "general_chat",
            "gather_info": "gather_info",
            "other_features": "other_features"
        }
    )
    
    workflow.add_conditional_edges(
        "feasibility_check",
        route_after_feasibility,
        {
            "gather_info": "gather_info",
            END: END
        }
    )
    
    workflow.add_conditional_edges(
        "gather_info",
        route_after_gathering,
        {
            "generate_document": "generate_document",
            END: END
        }
    )
    
    # Add edges to END
    workflow.add_edge("generate_document", END)
    workflow.add_edge("general_chat", END)
    workflow.add_edge("other_features", END)
    
    return workflow.compile()


# ============================================================================
# MAIN EXECUTION FUNCTION - Public API
# ============================================================================

def get_gemini_response(user_message: str, document_context: str = "", conversation_history: List[Dict] = None, signature_url: str = None):
    """
    Main function to generate AI responses using the stateful conversational agent.
    
    Args:
        user_message: The current user message
        document_context: Optional context about existing document
        conversation_history: Optional list of previous messages
        signature_url: Optional URL of uploaded signature
    
    Returns:
        str: The AI's response
    """
    # Initialize the graph
    graph = build_legal_document_graph()
    
    # Build message history (using simple dict format)
    messages = []
    if conversation_history:
        for msg in conversation_history:
            messages.append({"role": msg.get("role", "user"), "content": msg.get("content", "")})
    
    # Add document context to user message if provided
    full_message = user_message
    if document_context:
        full_message = f"Current document content:\n```markdown\n{document_context}\n```\n\nUser request: {user_message}"
    
    # Add signature URL as system message if provided
    if signature_url:
        messages.append({"role": "system", "content": f"(System: The user has uploaded a signature at URL: {signature_url})"})
    
    messages.append({"role": "user", "content": full_message})
    
    # Initialize state
    initial_state: ConversationState = {
        "messages": messages,
        "current_intent": "",
        "document_type": "",
        "is_feasible": False,
        "jurisdiction": "generic",
        "gathered_info": {},
        "needs_more_info": False,
        "user_wants_template": False,
        "user_wants_dummy_data": False,
        "final_document": "",
        "signature_url": signature_url,
        "next_step": ""
    }
    
    # Run the graph
    try:
        final_state = graph.invoke(initial_state)
        
        # Extract the last AI message (from dict format)
        ai_messages = [msg for msg in final_state["messages"] if isinstance(msg, dict) and msg.get("role") == "assistant"]
        if ai_messages:
            return ai_messages[-1].get("content", "")
        else:
            return "I apologize, but I couldn't process your request. Please try again."
    
    except Exception as e:
        return f"An error occurred: {str(e)}. Please try again or contact support."
